**Перечислення (enum) у TypeScript**

enum (перечислення) у TypeScript дозволяє визначати набір іменованих значень, які представляють
обмежену кількість варіантів. 
Це зручно для випадків, коли значення обмежуються певним набором, наприклад, статуси, ролі, дні тижня тощо.

**_1. Створення та використання enum:_**

```ts
enum UserRole {
  Admin = "admin",
  User = "user",
  Guest = "guest",
}
```
Цей enum створює тип UserRole, що може приймати одне з трьох значень: "admin", "user", або "guest". 
Кожен варіант прив’язаний до конкретного значення, що допомагає уникати помилок через випадкові введення рядків.


**_2. Використання enum як типу:_**

Перемикач (switch) — класичний приклад використання enum для обробки різних сценаріїв.
```ts
function getUserPermissions(role: UserRole): string[] {
    switch (role) {
        case UserRole.Admin:
            return ["read", "write", "delete"];
        case UserRole.User:
            return ["read", "write"];
        case UserRole.Guest:
            return ["read"];
        default:
            return [];
    }
}

const adminPermissions = getUserPermissions(UserRole.Admin); // ["read", "write", "delete"]
```

**_3. Обмеження значень через enum:_**

Якщо потрібно обмежити параметр певними значеннями, enum виконує цю задачу відмінно, 
запобігаючи передачі некоректних значень:
```ts
function performAction(status: UserRole): void {
  if (status === UserRole.Admin) {
    console.log("Admin actions are available.");
  } else if (status === UserRole.User) {
    console.log("User actions are available.");
  } else {
    console.log("Guest actions are limited.");
  }
}

performAction(UserRole.Guest); // "Guest actions are limited."
// performAction("other"); // Error: Argument of type '"other"' is not assignable to parameter of type 'UserRole'
```

**_приклад 1: Робота з числовими enum_**

Числові enum використовуються, коли кожен елемент має числове значення. 
Це може бути корисним для оптимізації зберігання або для завдань, де важливий порядок.
```ts
enum OrderStatus {
  Pending = 1,
  Shipped,
  Delivered,
  Cancelled,
}

function updateOrderStatus(status: OrderStatus) {
  if (status === OrderStatus.Pending) {
    console.log("Order is pending.");
  } else if (status === OrderStatus.Shipped) {
    console.log("Order has been shipped.");
  }
}

updateOrderStatus(OrderStatus.Shipped); // "Order has been shipped."
```
Кожен наступний елемент у числовому enum автоматично отримує значення попереднього елемента, 
збільшене на одиницю, що економить час при встановленні значень для всіх елементів.


**_приклад 2: Використання enum у поєднанні з інтерфейсами та функціями_**

Створимо систему статусів задач, де enum визначає статуси, а інтерфейс Task описує структуру задачі.
```ts
enum TaskStatus {
  NotStarted = "not_started",
  InProgress = "in_progress",
  Completed = "completed",
}

interface Task {
  id: number;
  name: string;
  status: TaskStatus;
}

const tasks: Task[] = [
  { id: 1, name: "Task 1", status: TaskStatus.NotStarted },
  { id: 2, name: "Task 2", status: TaskStatus.InProgress },
];

function filterTasksByStatus(tasks: Task[], status: TaskStatus): Task[] {
  return tasks.filter((task) => task.status === status);
}

const inProgressTasks = filterTasksByStatus(tasks, TaskStatus.InProgress);
console.log(inProgressTasks); // [{ id: 2, name: "Task 2", status: "in_progress" }]
```

Але є випадки, коли TypeScript **не може автоматично визначити значення в enum**. 
Це часто трапляється, коли в enum використовуються комбіновані значення, такі як
змішані числові та рядкові елементи, або коли потрібно точно задати порядок для числових enum.

**_Змішані числові та рядкові значення_**

TypeScript очікує, що всі елементи у числовому enum мають послідовні значення. 
Якщо ж у enum змішані числові та рядкові значення, TypeScript не може автоматично визначити
значення для елементів після рядкового, і це потребує явного зазначення значення кожного елемента.

```ts
enum MixedEnum {
  A = 1,       // Числове значення
  B = "value", // Рядкове значення
  C = 2,       // Помилка: Enum member must have initializer
}
```
У цьому прикладі TypeScript не може визначити значення для C, 
оскільки після рядкового значення автоматичне присвоєння числових значень припиняється. 
Щоб це виправити, необхідно явно задати значення для C.

```ts
enum MixedEnum {
  A = 1,
  B = "value",
  C = 3, // Вказуємо явне значення
}
```

**_Пропущені або неявні значення_**

В числовому enum, якщо не вказати значення для першого елемента, він за замовчуванням отримує 0,
а наступні елементи збільшуються на одиницю. 
Проте, якщо почати з іншого значення, TypeScript продовжить автоматичне збільшення.

```ts
enum StatusCode {
  Success = 200,
  Redirect,        // 201
  BadRequest = 400,
  Unauthorized,    // 401
}
```
Тут Redirect автоматично отримує 201, оскільки StatusCode продовжує рахувати з 200, 
але Unauthorized також потребує явного зазначення, якщо порядок значень має значення, наприклад:
```ts
enum StatusCode {
  Success = 200,
  Redirect = 301,  // Ручне встановлення значення
  BadRequest = 400,
  Unauthorized = 401,
}
```
Таким чином, коли в enum є змішані або неявні значення, TypeScript не може автоматично
визначити порядок чи значення.

---------------------------------ДОДАТКОВО-------------------------------------------------------

**_1. Використання бітових прапорців (Bit Flags)_**

Іноді enum використовуються для опису бітових прапорців (bit flags), коли кожен елемент
представляє значення певного біта. 
Це дозволяє комбінувати кілька значень одночасно за допомогою побітових операцій. 
У такому випадку значення елементів задаються вручну, і TypeScript не може їх автоматично визначити.

```ts
enum FileAccess {
  Read = 1 << 0,  // 1
  Write = 1 << 1, // 2
  Execute = 1 << 2, // 4
  Delete = 1 << 3, // 8
}

function checkPermissions(permission: number) {
  if (permission & FileAccess.Read) {
    console.log("Read permission granted");
  }
  if (permission & FileAccess.Write) {
    console.log("Write permission granted");
  }
}

const permission = FileAccess.Read | FileAccess.Write;
checkPermissions(permission); 
// Виведе:
// "Read permission granted"
// "Write permission granted"
```
У цьому прикладі кожне значення FileAccess представляє окремий біт, а побітова операція | (OR) дозволяє
поєднувати значення, що зручно для перевірки різних рівнів доступу. 
TypeScript не може автоматично визначити ці значення, оскільки вони є степенями двійки.


**_2. Неявне привласнення значень у рядкових enum_**

Для рядкових enum кожному елементу необхідно призначити значення вручну. 
На відміну від числових enum, де TypeScript може продовжити послідовність значень автоматично, 
у рядкових enum для кожного елемента треба вказувати конкретне значення.

```ts
enum Color {
  Red = "RED",
  Green = "GREEN",
  Blue = "BLUE",
}
```
Тут автоматичного визначення значень не відбувається, тому кожен елемент повинен мати явне значення. 
Це може здатися обмеженням, але рядкові enum є корисними для уникнення неочікуваних значень, 
особливо коли важлива точна відповідність рядкових констант.


**_3. Проблема з логікою перевірки значень у числових enum**_

Числові enum можуть бути піддані нестандартним значенням, які не належать до визначених у enum. 
Це може призвести до небажаних результатів, коли значення не відповідає жодному з очікуваних 
елементів enum. У таких випадках TypeScript не видає помилку, що може спричинити непередбачувану поведінку.

```ts
enum Status {
  Active = 1,
  Inactive,
  Paused,
}

function logStatus(status: Status) {
  if (status === Status.Active) {
    console.log("Active");
  } else if (status === Status.Inactive) {
    console.log("Inactive");
  } else if (status === Status.Paused) {
    console.log("Paused");
  } else {
    console.log("Unknown status"); // це може трапитися, якщо передати невалідне значення
  }
}

logStatus(10); // "Unknown status"
```
Це можливо через те, що числові enum у TypeScript є «нестрогими», і можна передати значення, 
яке не визначене в enum. Щоб обмежити можливі значення, краще використовувати рядкові enum або 
додаткову перевірку валідності перед обробкою.


**_4. Перетворення enum у типи для кращої типізації_**

Іноді enum використовуються як типи для обмеження можливих значень аргументів або властивостей, 
але можна також створювати «союз» (Union) значень enum, щоб досягти кращої типізації і уникнути 
передачі невалідних значень у функції.

```ts
enum Direction {
  Up = "UP",
  Down = "DOWN",
  Left = "LEFT",
  Right = "RIGHT",
}

type DirectionType = keyof typeof Direction;

function move(direction: DirectionType) {
  console.log(`Moving ${Direction[direction]}`);
}

move("Up"); // працює
// move("Diagonal"); // Помилка: Argument of type '"Diagonal"' is not assignable to parameter of type 'DirectionType'
```
Тут keyof typeof Direction створює тип DirectionType, що обмежує значення до тих, що визначені у enum.
Це запобігає передачі будь-яких невалідних значень, зберігаючи строгість типізації.

